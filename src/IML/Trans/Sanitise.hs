
-- | Assuming the statements are in a dependency preserving order,
-- remove certain redundant statements from a sequence of statements.
module IML.Trans.Sanitise where

import IML.Trans.ProMan
import IML.Grammar
import IML.Grammar.Bindings

import qualified Data.Map as M

remove_rebindings :: Functor a => Component (a [Stmts]) (a [Stmts])
remove_rebindings = component_ (fmap (fmap (rMVarRename subsEmpty)))

-- The `remove-common-rewrites` optimisation may introduce a previouly
-- unexisting dependency!
remove_common_rewrites :: Functor a => Component (a [Stmts]) (a [Stmts])
remove_common_rewrites = component_ (fmap (fmap (rRewrites M.empty)))


rMVarRename :: SubsEnv -> Stmts -> Stmts
rMVarRename env ss = case ss of
  []              -> []
  [Branches sss]  -> [Branches (map (rMVarRename env) sss)]
  (s:ss)  -> case sub_mvars env s of
    -- if a pm-statement has just two meta-variables let the first take the
    -- place of the second in all subsequence statements
    PM (ETerm (TVar v1)) (PVar (v2)) 
                  -> rMVarRename (subsInsert v2 v1 env) ss
    Branches sss  -> error "rMVarRename: assert1" 
    s'            -> s' : rMVarRename env ss

rRewrites :: RewEnv -> Stmts -> Stmts
rRewrites env [] = []
rRewrites env (s:ss) = case s of
  -- avoid context-free transition a second time on term `t`
  -- Nothing is generated by ToLower, based on relation declarations 
  -- When running into `x` later, replace it by `x2` as well as `t`
  Single r t x Nothing  | Just x2 <- M.lookup t env -> 
                            rRewrites (M.insert (TVar x) x2 env) ss
  Many r t x Nothing    | Just x2 <- M.lookup t env ->  
                            rRewrites (M.insert (TVar x) x2 env) ss
  -- previously rewritten terms may be embedded in `t` though
  -- that is why there are the cases for single/many below
  _ -> case sub_terms env s of
    -- "memoise" context-free transitions by replacing further occurrences
    -- of `t` by `x`, the variable to which the result is bound
    -- possibly introduces dependencies!
    s'@(Single r t x Nothing) -> s' : rRewrites (M.insert t x env) ss
    s'@(Many r t x Nothing)   -> s' : rRewrites (M.insert t x env) ss 
    s'                        -> s' : rRewrites env ss

type RewEnv = M.Map Term MVar

class HasTerms a where
  sub_terms :: RewEnv -> a -> a 

instance (HasTerms a, HasTerms b) => HasTerms (Either a b) where
  sub_terms env (Left a) = Left (sub_terms env a)
  sub_terms env (Right a) = Right (sub_terms env a)

instance HasTerms Stmt where
  sub_terms env s = case s of
    Single r t x ml -> Single r (sub_terms env t) x ml
    Many r t x ml   -> Many r (sub_terms env t) x ml
    PM e p          -> PM (sub_terms env e) p
    Branches sss    -> Branches (map (map (sub_terms env)) sss)
    Commit t        -> Commit (sub_terms env t)
    RO_Get _ _      -> s
    RW_Get _ _ _    -> s
    WO_Get _ _ _    -> s
    RO_Set n e l    -> RO_Set n (sub_terms env e) l
    RW_Set n e l    -> RW_Set n (sub_terms env e) l
    WO_Set n e      -> WO_Set n (sub_terms env e)
    Unobserv _      -> s

instance HasTerms Expr where
  sub_terms env e = case e of
    ETerm t   -> ETerm (sub_terms env t)
    VOP op es -> VOP op (map (sub_terms env) es)

instance HasTerms Term where
  sub_terms env t = case M.lookup t env of
    Nothing -> case t of  TVar v      -> TVar v
                          TVal v      -> TVal v
                          TCons c ts  -> TCons c (map (sub_terms env) ts) 
    Just v  -> TVar v

